{"version":3,"sources":["generated/graphql.tsx","components/character-data/character-data.tsx","components/character-table/character-table.tsx","components/app/app.tsx","config/apollo-http-link.ts","config/apollo-error-lnk.ts","config/apollo-local-cache.ts","config/apollo-client.ts","serviceWorker.ts","index.tsx"],"names":["CacheControlScope","GetCharactersDocument","gql","useStyles","makeStyles","theme","createStyles","nameTableCell","display","alignItems","characterImg","maxHeight","width","borderRadius","characterName","paddingLeft","spacing","CharacterData","props","classes","TableRow","TableCell","className","Box","src","character","image","alt","Typography","variant","name","species","origin","location","CharacterTable","baseOptions","ApolloReactHooks","data","loading","error","CircularProgress","characters","results","TableContainer","component","Paper","Table","TableHead","TableBody","map","key","id","root","paddingTop","paddingBottom","httpLink","HttpLink","uri","errorLink","onError","graphQLErrors","networkError","response","operation","console","message","locations","path","localCache","InMemoryCache","freezeResults","apolloClient","ApolloClient","link","ApolloLink","from","connectToDevTools","process","cache","assumeImmutableResults","Boolean","window","hostname","match","ReactDOM","render","client","Container","justifyContent","alignContent","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.123bf0e5.chunk.js","sourcesContent":["import gql from 'graphql-tag';\nimport * as React from 'react';\nimport * as ApolloReactCommon from '@apollo/react-common';\nimport * as ApolloReactComponents from '@apollo/react-components';\nimport * as ApolloReactHoc from '@apollo/react-hoc';\nimport * as ApolloReactHooks from '@apollo/react-hooks';\nexport type Maybe<T> = T | null;\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string,\n  String: string,\n  Boolean: boolean,\n  Int: number,\n  Float: number,\n  Upload: any,\n};\n\nexport enum CacheControlScope {\n  Public = 'PUBLIC',\n  Private = 'PRIVATE'\n}\n\nexport type Character = {\n   __typename?: 'Character',\n  id?: Maybe<Scalars['ID']>,\n  name?: Maybe<Scalars['String']>,\n  status?: Maybe<Scalars['String']>,\n  species?: Maybe<Scalars['String']>,\n  type?: Maybe<Scalars['String']>,\n  gender?: Maybe<Scalars['String']>,\n  origin?: Maybe<Location>,\n  location?: Maybe<Location>,\n  image?: Maybe<Scalars['String']>,\n  episode?: Maybe<Array<Maybe<Episode>>>,\n  created?: Maybe<Scalars['String']>,\n};\n\nexport type Characters = {\n   __typename?: 'Characters',\n  info?: Maybe<Info>,\n  results?: Maybe<Array<Maybe<Character>>>,\n};\n\nexport type Episode = {\n   __typename?: 'Episode',\n  id?: Maybe<Scalars['ID']>,\n  name?: Maybe<Scalars['String']>,\n  air_date?: Maybe<Scalars['String']>,\n  episode?: Maybe<Scalars['String']>,\n  characters?: Maybe<Array<Maybe<Character>>>,\n  created?: Maybe<Scalars['String']>,\n};\n\nexport type Episodes = {\n   __typename?: 'Episodes',\n  info?: Maybe<Info>,\n  results?: Maybe<Array<Maybe<Episode>>>,\n};\n\nexport type FilterCharacter = {\n  name?: Maybe<Scalars['String']>,\n  status?: Maybe<Scalars['String']>,\n  species?: Maybe<Scalars['String']>,\n  type?: Maybe<Scalars['String']>,\n  gender?: Maybe<Scalars['String']>,\n};\n\nexport type FilterEpisode = {\n  name?: Maybe<Scalars['String']>,\n  episode?: Maybe<Scalars['String']>,\n};\n\nexport type FilterLocation = {\n  name?: Maybe<Scalars['String']>,\n  type?: Maybe<Scalars['String']>,\n  dimension?: Maybe<Scalars['String']>,\n};\n\nexport type Info = {\n   __typename?: 'Info',\n  count?: Maybe<Scalars['Int']>,\n  pages?: Maybe<Scalars['Int']>,\n  next?: Maybe<Scalars['Int']>,\n  prev?: Maybe<Scalars['Int']>,\n};\n\nexport type Location = {\n   __typename?: 'Location',\n  id?: Maybe<Scalars['ID']>,\n  name?: Maybe<Scalars['String']>,\n  type?: Maybe<Scalars['String']>,\n  dimension?: Maybe<Scalars['String']>,\n  residents?: Maybe<Array<Maybe<Character>>>,\n  created?: Maybe<Scalars['String']>,\n};\n\nexport type Locations = {\n   __typename?: 'Locations',\n  info?: Maybe<Info>,\n  results?: Maybe<Array<Maybe<Location>>>,\n};\n\nexport type Query = {\n   __typename?: 'Query',\n  character?: Maybe<Character>,\n  characters?: Maybe<Characters>,\n  location?: Maybe<Location>,\n  locations?: Maybe<Locations>,\n  episode?: Maybe<Episode>,\n  episodes?: Maybe<Episodes>,\n};\n\n\nexport type QueryCharacterArgs = {\n  id?: Maybe<Scalars['ID']>\n};\n\n\nexport type QueryCharactersArgs = {\n  page?: Maybe<Scalars['Int']>,\n  filter?: Maybe<FilterCharacter>\n};\n\n\nexport type QueryLocationArgs = {\n  id?: Maybe<Scalars['ID']>\n};\n\n\nexport type QueryLocationsArgs = {\n  page?: Maybe<Scalars['Int']>,\n  filter?: Maybe<FilterLocation>\n};\n\n\nexport type QueryEpisodeArgs = {\n  id?: Maybe<Scalars['ID']>\n};\n\n\nexport type QueryEpisodesArgs = {\n  page?: Maybe<Scalars['Int']>,\n  filter?: Maybe<FilterEpisode>\n};\n\n\nexport type GetCharactersQueryVariables = {};\n\n\nexport type GetCharactersQuery = (\n  { __typename?: 'Query' }\n  & { characters: Maybe<(\n    { __typename: 'Characters' }\n    & { results: Maybe<Array<Maybe<(\n      { __typename: 'Character' }\n      & Pick<Character, 'id' | 'name' | 'image' | 'species'>\n      & { origin: Maybe<(\n        { __typename: 'Location' }\n        & Pick<Location, 'id' | 'name'>\n      )>, location: Maybe<(\n        { __typename: 'Location' }\n        & Pick<Location, 'id' | 'name'>\n      )> }\n    )>>> }\n  )> }\n);\n\n\nexport const GetCharactersDocument = gql`\n    query GetCharacters {\n  characters {\n    __typename\n    results {\n      id\n      __typename\n      name\n      image\n      species\n      origin {\n        id\n        __typename\n        name\n      }\n      location {\n        id\n        __typename\n        name\n      }\n    }\n  }\n}\n    `;\nexport type GetCharactersComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<GetCharactersQuery, GetCharactersQueryVariables>, 'query'>;\n\n    export const GetCharactersComponent = (props: GetCharactersComponentProps) => (\n      <ApolloReactComponents.Query<GetCharactersQuery, GetCharactersQueryVariables> query={GetCharactersDocument} {...props} />\n    );\n    \nexport type GetCharactersProps<TChildProps = {}> = ApolloReactHoc.DataProps<GetCharactersQuery, GetCharactersQueryVariables> & TChildProps;\nexport function withGetCharacters<TProps, TChildProps = {}>(operationOptions?: ApolloReactHoc.OperationOption<\n  TProps,\n  GetCharactersQuery,\n  GetCharactersQueryVariables,\n  GetCharactersProps<TChildProps>>) {\n    return ApolloReactHoc.withQuery<TProps, GetCharactersQuery, GetCharactersQueryVariables, GetCharactersProps<TChildProps>>(GetCharactersDocument, {\n      alias: 'getCharacters',\n      ...operationOptions\n    });\n};\n\n/**\n * __useGetCharactersQuery__\n *\n * To run a query within a React component, call `useGetCharactersQuery` and pass it any options that fit your needs.\n * When your component renders, `useGetCharactersQuery` returns an object from Apollo Client that contains loading, error, and data properties \n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useGetCharactersQuery({\n *   variables: {\n *   },\n * });\n */\nexport function useGetCharactersQuery(baseOptions?: ApolloReactHooks.QueryHookOptions<GetCharactersQuery, GetCharactersQueryVariables>) {\n        return ApolloReactHooks.useQuery<GetCharactersQuery, GetCharactersQueryVariables>(GetCharactersDocument, baseOptions);\n      }\nexport function useGetCharactersLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<GetCharactersQuery, GetCharactersQueryVariables>) {\n          return ApolloReactHooks.useLazyQuery<GetCharactersQuery, GetCharactersQueryVariables>(GetCharactersDocument, baseOptions);\n        }\nexport type GetCharactersQueryHookResult = ReturnType<typeof useGetCharactersQuery>;\nexport type GetCharactersLazyQueryHookResult = ReturnType<typeof useGetCharactersLazyQuery>;\nexport type GetCharactersQueryResult = ApolloReactCommon.QueryResult<GetCharactersQuery, GetCharactersQueryVariables>;\n\n      export interface IntrospectionResultData {\n        __schema: {\n          types: {\n            kind: string;\n            name: string;\n            possibleTypes: {\n              name: string;\n            }[];\n          }[];\n        };\n      }\n      const result: IntrospectionResultData = {\n  \"__schema\": {\n    \"types\": []\n  }\n};\n      export default result;\n    ","import React, { ReactElement } from 'react';\nimport { Character, Maybe } from '../../generated/graphql';\nimport {\n  TableRow,\n  TableCell,\n  Box,\n  createStyles,\n  Theme,\n  makeStyles,\n  Typography,\n} from '@material-ui/core';\n\ninterface Props {\n  character: Maybe<Character | null>;\n}\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    nameTableCell: {\n      display: 'flex',\n      alignItems: 'center',\n    },\n    characterImg: {\n      maxHeight: '3rem',\n      width: 'auto',\n      borderRadius: '50%',\n    },\n    characterName: {\n      paddingLeft: theme.spacing(2),\n    },\n  })\n);\n\nexport default function CharacterData(props: Props): ReactElement {\n  const classes = useStyles();\n\n  return (\n    <TableRow>\n      <TableCell className={classes.nameTableCell}>\n        <Box>\n          <img src={props.character?.image!} alt='' className={classes.characterImg} />\n        </Box>\n        <Typography variant='body2' className={classes.characterName}>\n          {props.character?.name}\n        </Typography>\n      </TableCell>\n      <TableCell>{props.character?.species}</TableCell>\n      <TableCell>{props.character?.origin?.name}</TableCell>\n      <TableCell>{props.character?.location?.name}</TableCell>\n    </TableRow>\n  );\n}\n","import {\n  CircularProgress,\n  Paper,\n  Table,\n  TableBody,\n  TableCell,\n  TableContainer,\n  TableHead,\n  TableRow,\n  Typography,\n} from '@material-ui/core';\nimport React, { ReactElement } from 'react';\nimport { useGetCharactersQuery } from '../../generated/graphql';\nimport CharacterData from '../character-data/character-data';\n\ninterface Props {}\n\nexport default function CharacterTable(props: Props): ReactElement {\n  // Use hook to retrieve data from the backend\n  const { data, loading, error } = useGetCharactersQuery();\n\n  // Query state management\n  if (loading) {\n    return <CircularProgress />;\n  } else if (error) {\n    return (\n      <Typography variant='h5'>\n        Error retrieving data, please reload the page to try again.\n      </Typography>\n    );\n  } else if (!data || !data.characters || !data.characters.results) {\n    return (\n      <Typography variant='h5'>No data available, please reload the page to try again.</Typography>\n    );\n  }\n\n  // Display the data\n  return (\n    <TableContainer component={Paper}>\n      <Table>\n        <TableHead>\n          <TableRow>\n            <TableCell>\n              <strong>Name</strong>\n            </TableCell>\n            <TableCell>\n              <strong>Species</strong>\n            </TableCell>\n            <TableCell>\n              <strong>Origin</strong>\n            </TableCell>\n            <TableCell>\n              <strong>Location</strong>\n            </TableCell>\n          </TableRow>\n        </TableHead>\n        <TableBody>\n          {data.characters.results.map(character => (\n            <CharacterData character={character} key={character?.id!} />\n          ))}\n        </TableBody>\n      </Table>\n    </TableContainer>\n  );\n}\n","import React, { ReactElement } from 'react';\nimport { Container, Box, Theme, makeStyles, createStyles } from '@material-ui/core';\nimport CharacterTable from '../character-table/character-table';\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    root: {\n      paddingTop: theme.spacing(2),\n      paddingBottom: theme.spacing(2),\n    },\n  })\n);\n\nexport default function App(): ReactElement {\n  const classes = useStyles();\n\n  return (\n    <Container className={classes.root}>\n      <Box display='flex' justifyContent='center' alignContent='center'>\n        <CharacterTable />\n      </Box>\n    </Container>\n  );\n}\n","import { HttpLink } from 'apollo-link-http';\n\nexport const httpLink = new HttpLink({\n  uri: 'https://rickandmortyapi.com/graphql',\n});\n","import { onError } from 'apollo-link-error';\n\nexport const errorLink = onError(({ graphQLErrors, networkError, response, operation }) => {\n  if (graphQLErrors) {\n    for (const error of graphQLErrors) {\n      console.error(\n        `[GraphQL error]: Message: ${error.message}, Location: ${error.locations}, Path: ${error.path}`,\n        operation,\n        response\n      );\n    }\n  }\n  if (networkError) {\n    console.error(`[Network error]: ${networkError}`, operation, response);\n  }\n});\n","import { InMemoryCache } from 'apollo-cache-inmemory';\n\nexport const localCache = new InMemoryCache({\n  freezeResults: true,\n});\n","import { ApolloClient } from 'apollo-client';\nimport { ApolloLink } from 'apollo-link';\nimport { httpLink } from './apollo-http-link';\nimport { errorLink } from './apollo-error-lnk';\nimport { localCache } from './apollo-local-cache';\n\nexport const apolloClient = new ApolloClient({\n  link: ApolloLink.from([errorLink, httpLink]),\n  connectToDevTools: process.env.NODE_ENV !== 'production',\n  cache: localCache,\n  assumeImmutableResults: true,\n});\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import { ApolloProvider } from '@apollo/react-hooks';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/app/app';\nimport { apolloClient } from './config/apollo-client';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <ApolloProvider client={apolloClient}>\n    <App />\n  </ApolloProvider>,\n  document.getElementById('root')\n);\n\nserviceWorker.unregister();\n"],"sourceRoot":""}